# Controlling Processes

* **PID - process ID number** - assigned to every process by kernel
* **PPID - parent process ID number** - useful when confronted with unrecognized (and possibly missbehaving) process
* **EUID - effective user ID** - related to user of process 
* **EGID - effective group ID** - related to group of process

## Life cycle of a process

* to create a new process, a (parent) process copies itself with **fork** system call
* child process will often use **exec** family of system calls to begin execution of new program
* when done child calls **_exit** + exit code which gets received by parent process by a sys call to **wait**

## Signals

* process level interrupts
* can be sent as means of communication **between processes**
* tan be sent by terminal (driver) to **kill, suspend or interrupt** process
* tan be sent by admins (with **kill**)
* tan be sent by kernel when process commits an infraction (divide by zero e.g.t)
* can be sent by kernel to inform processes (e.g. about IO event)
* if signal is **not handled by program** kernel takes default action on behalf
* often times **process gets terminated** or core gets dumped
* signals can also be ignored or blocked
* examples of signals **HUP, INT, QUIT, KILL, STOP, TSTP (soft version of kill) WINCH**

* **quote from unix handbook**

• **KILL** is unblockable and terminates a process at the kernel level. A pro-
cess can never actually receive this signal.
• **INT** is sent by the terminal driver when you type <Control-C>. It’s a
request to terminate the current operation. Simple programs should quit
(if they catch the signal) or simply allow themselves to be killed, which is
the default if the signal is not caught. Programs that have an interactive
command line (such as a shell) should stop what they’re doing, clean up,
and wait for user input again.
• **TERM** is a request to terminate execution completely. It’s expected that
the receiving process will clean up its state and exit.
• **HUP** has two common interpretations. First, it’s understood as a reset
request by many daemons. If a daemon is capable of rereading its config-
uration file and adjusting to changes without restarting, a HUP can gen-
erally be used to trigger this behavior.  
Second, HUP signals are sometimes generated by the terminal driver in
an attempt to “clean up” (i.e., kill) the processes attached to a particular
terminal. This behavior is largely a holdover from the days of wired ter-
minals and modem connections, hence the name “hangup.”
• **QUIT** is similar to TERM, except that it defaults to producing a core
dump if not caught. A few programs cannibalize this signal and interpret
it to mean something else.

* **kill and pkill** send signals 

## Process states

* Runnable - The process can be executed
* Sleeping - The process is waiting for some resource
* Zombie - The process is trying to die (motherfucker die).
* Stoppped - The process is suspended (not allowed to execute)

# Niceness

* determines how much priority the process has
* the higher the value - the lower the prio
* range: **-20 to 19**
* adjusted with **renice** and set up on creation with **nice**
* not often needed these days

# PS

* **ps aux** 
* (processes in brackets = kernel threads)
* **ps lax** - more technical info (l for long)

## TOP 

* root can invoke with *-q option* to give top process very high prio

## /PROC

* pseudo filesystem where process status info is stored
* exposes interesting info about the systems state
* **man proc** for tips and tricks

## strace

* **sudo strace -c -p PID**
* lots of goodies, read man

## Runaway processes

* **uptime** command to show load averages
* use *ps* and *top* to monitor
* very informing of process is DATA column of **top** - not seen by default - press f once and select DATA from list.
* change **sorting column** with '< and >'
* **df -k** shows file system use
* use **du** on filesystems mountpoint (e.g. /dev) to find which dir is using the most space
* use **fuser** and **lsof** commands to determine which process is accessing a file